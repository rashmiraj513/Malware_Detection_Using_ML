# Import the necessary packages
import pefile
import os
import array
import math
import pickle
import joblib
import sys
import argparse

# Function to get entropy of data
def get_entropy(data):
  '''
  Calculate the entropy of a given data sequence.

  Args:
    data (str or list): Input data sequence as a string or list of integers.

  Returns:
    float: Entropy value of the data sequence.
  '''
  # Check if the data sequence is empty
  if len(data) == 0:
    return 0.0

  # Initialize an array to store occurrences of each byte value (0-255)
  occurrences = array.array('L', [0]*256)

  # Count occurrences of each byte value in the data
  for x in data:
    # Convert non-integer elements to their ASCII values
    occurrences[x if isinstance(x, int) else ord(x)] += 1

  entropy = 0
  # Calculate entropy using Shannon's entropy formula
  for x in occurrences:
    if x:
      p_x = float(x) / len(data)  # Probability of byte value x
      entropy -= p_x * math.log(p_x, 2)  # Shannon's entropy formula

  return entropy

# Function to get resources from a portable executable file
def get_resources(pe):
  '''
  Extracts resource information (entropy and size) from a Portable Executable (PE) file.

  Args:
    pe (pefile.PE): PE file object obtained using pefile library.

  Returns:
    list: List of resource information containing entropy and size for each resource.
  '''
  resources = []

  # Check if the PE file has a resource directory
  if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
    try:
      # Iterate through each resource type
      for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
        if hasattr(resource_type, 'directory'):
          # Iterate through each resource ID
          for resource_id in resource_type.directory.entries:
            if hasattr(resource_id, 'directory'):
              # Iterate through each resource language
              for resource_lang in resource_id.directory.entries:
                # Get the resource data, size, and calculate entropy
                data = pe.get_data(resource_lang.data.struct.OffsetToData, resource_lang.data.struct.Size)
                size = resource_lang.data.struct.Size
                entropy = get_entropy(data)
                resources.append([entropy, size])  # Add entropy and size to the resources list
    except Exception as e:
      # Return empty list if an exception occurs
      return resources  

  # Return the list of resource information
  return resources  

# Function to get the version information from a portable executable file
def get_version_info(pe):
  '''
  Extracts version information from a Portable Executable (PE) file.

  Args:
    pe (pefile.PE): PE file object obtained using pefile library.

  Returns:
    dict: Dictionary containing version information extracted from the PE file.
  '''
  res = {}

  # Iterate through each file info entry in the PE file
  for fileinfo in pe.FileInfo:
    # Check if the file info key is 'StringFileInfo'
    if fileinfo.Key == 'StringFileInfo':
      # Iterate through each string table in 'StringFileInfo'
      for st in fileinfo.StringTable:
        # Iterate through each entry in the string table
        for entry in st.entries.items():
          # Add entry to the result dictionary
          res[entry[0]] = entry[1]  

    # Check if the file info key is 'VarFileInfo'
    if fileinfo.Key == 'VarFileInfo':
      # Iterate through each variable in 'VarFileInfo'
      for var in fileinfo.Var:
        # Add variable to the result dictionary
        res[var.entry.items()[0][0]] = var.entry.items()[0][1]  

  # Check if the PE file has version information
  if hasattr(pe, 'VS_FIXEDFILEINFO'):
    # Add version information to the result dictionary
    res['flags'] = pe.VS_FIXEDFILEINFO.FileFlags
    res['os'] = pe.VS_FIXEDFILEINFO.FileOS
    res['type'] = pe.VS_FIXEDFILEINFO.FileType
    res['file_version'] = pe.VS_FIXEDFILEINFO.FileVersionLS
    res['product_version'] = pe.VS_FIXEDFILEINFO.ProductVersionLS
    res['signature'] = pe.VS_FIXEDFILEINFO.Signature
    res['struct_version'] = pe.VS_FIXEDFILEINFO.StrucVersion

  # Return the dictionary containing version information
  return res  

# Function to get extract information from a file path along with file name
def extract_infos(fpath):
  '''
  Extracts various information from a Portable Executable (PE) file using pefile library.

  Args:
    fpath (str): Path to the PE file.

  Returns:
    dict: Dictionary containing extracted information from the PE file.
  '''
  res = {}
  # Load the PE file using pefile library
  pe = pefile.PE(fpath)  

  # Extract basic header information
  res['Machine'] = pe.FILE_HEADER.Machine
  res['SizeOfOptionalHeader'] = pe.FILE_HEADER.SizeOfOptionalHeader
  res['Characteristics'] = pe.FILE_HEADER.Characteristics
  res['MajorLinkerVersion'] = pe.OPTIONAL_HEADER.MajorLinkerVersion
  res['MinorLinkerVersion'] = pe.OPTIONAL_HEADER.MinorLinkerVersion
  res['SizeOfCode'] = pe.OPTIONAL_HEADER.SizeOfCode
  res['SizeOfInitializedData'] = pe.OPTIONAL_HEADER.SizeOfInitializedData
  res['SizeOfUninitializedData'] = pe.OPTIONAL_HEADER.SizeOfUninitializedData
  res['AddressOfEntryPoint'] = pe.OPTIONAL_HEADER.AddressOfEntryPoint
  res['BaseOfCode'] = pe.OPTIONAL_HEADER.BaseOfCode
  
  # Handle cases where 'BaseOfData' attribute is not available
  try:
    res['BaseOfData'] = pe.OPTIONAL_HEADER.BaseOfData
  except AttributeError:
    res['BaseOfData'] = 0

  # Extract additional optional header information
  res['ImageBase'] = pe.OPTIONAL_HEADER.ImageBase
  res['SectionAlignment'] = pe.OPTIONAL_HEADER.SectionAlignment
  res['FileAlignment'] = pe.OPTIONAL_HEADER.FileAlignment
  res['MajorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MajorOperatingSystemVersion
  res['MinorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MinorOperatingSystemVersion
  res['MajorImageVersion'] = pe.OPTIONAL_HEADER.MajorImageVersion
  res['MinorImageVersion'] = pe.OPTIONAL_HEADER.MinorImageVersion
  res['MajorSubsystemVersion'] = pe.OPTIONAL_HEADER.MajorSubsystemVersion
  res['MinorSubsystemVersion'] = pe.OPTIONAL_HEADER.MinorSubsystemVersion
  res['SizeOfImage'] = pe.OPTIONAL_HEADER.SizeOfImage
  res['SizeOfHeaders'] = pe.OPTIONAL_HEADER.SizeOfHeaders
  res['CheckSum'] = pe.OPTIONAL_HEADER.CheckSum
  res['Subsystem'] = pe.OPTIONAL_HEADER.Subsystem
  res['DllCharacteristics'] = pe.OPTIONAL_HEADER.DllCharacteristics
  res['SizeOfStackReserve'] = pe.OPTIONAL_HEADER.SizeOfStackReserve
  res['SizeOfStackCommit'] = pe.OPTIONAL_HEADER.SizeOfStackCommit
  res['SizeOfHeapReserve'] = pe.OPTIONAL_HEADER.SizeOfHeapReserve
  res['SizeOfHeapCommit'] = pe.OPTIONAL_HEADER.SizeOfHeapCommit
  res['LoaderFlags'] = pe.OPTIONAL_HEADER.LoaderFlags
  res['NumberOfRvaAndSizes'] = pe.OPTIONAL_HEADER.NumberOfRvaAndSizes

  # Sections
  res['SectionsNb'] = len(pe.sections)
  entropy = list(map(lambda x: x.get_entropy(), pe.sections))
  res['SectionsMeanEntropy'] = sum(entropy)/float(len(entropy))
  res['SectionsMinEntropy'] = min(entropy)
  res['SectionsMaxEntropy'] = max(entropy)
  raw_sizes = list(map(lambda x: x.SizeOfRawData, pe.sections))
  res['SectionsMeanRawsize'] = sum(raw_sizes)/float(len(raw_sizes))
  res['SectionsMinRawsize'] = min(raw_sizes)
  res['SectionsMaxRawsize'] = max(raw_sizes)
  virtual_sizes = list(map(lambda x: x.Misc_VirtualSize, pe.sections))
  res['SectionsMeanVirtualsize'] = sum(virtual_sizes)/float(len(virtual_sizes))
  res['SectionsMinVirtualsize'] = min(virtual_sizes)
  res['SectionMaxVirtualsize'] = max(virtual_sizes)

  # Imports
  try:
    res['ImportsNbDLL'] = len(pe.DIRECTORY_ENTRY_IMPORT)
    imports = sum([x.imports for x in pe.DIRECTORY_ENTRY_IMPORT], [])
    res['ImportsNb'] = len(imports)
    res['ImportsNbOrdinal'] = len(list(filter(lambda x: x.name is None, imports)))
  except AttributeError:
    res['ImportsNbDLL'] = 0
    res['ImportsNb'] = 0
    res['ImportsNbOrdinal'] = 0

  # Exports
  try:
    res['ExportNb'] = len(pe.DIRECTORY_ENTRY_EXPORT.symbols)
  except AttributeError:
    # No export
    res['ExportNb'] = 0

  # Resources
  resources = get_resources(pe)
  res['ResourcesNb'] = len(resources)
  if len(resources) > 0:
    entropy = list(map(lambda x: x[0], resources))
    res['ResourcesMeanEntropy'] = sum(entropy)/float(len(entropy))
    res['ResourcesMinEntropy'] = min(entropy)
    res['ResourcesMaxEntropy'] = max(entropy)
    sizes = list(map(lambda x: x[1], resources))
    res['ResourcesMeanSize'] = sum(sizes)/float(len(sizes))
    res['ResourcesMinSize'] = min(sizes)
    res['ResourcesMaxSize'] = max(sizes)
  else:
    res['ResourcesNb'] = 0
    res['ResourcesMeanEntropy'] = 0
    res['ResourcesMinEntropy'] = 0
    res['ResourcesMaxEntropy'] = 0
    res['ResourcesMeanSize'] = 0
    res['ResourcesMinSize'] = 0
    res['ResourcesMaxSize'] = 0

  # Load configuration size
  try:
    res['LoadConfigurationSize'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.Size
  except AttributeError:
    res['LoadConfigurationSize'] = 0

  # Version configuration size
  try:
    version_infos = get_version_info(pe)
    res['VersionInformationSize'] = len(version_infos.keys())
  except AttributeError:
    res['VersionInformationSize'] = 0
  # Return the dictionary containing extracted information
  return res  

# Driver Code
if __name__ == '__main__':
  # List of all columns in the dataset
  columns = [
    "Name",
    "md5",
    "Machine",
    "SizeOfOptionalHeader",
    "Characteristics",
    "MajorLinkerVersion",
    "MinorLinkerVersion",
    "SizeOfCode",
    "SizeOfInitializedData",
    "SizeOfUninitializedData",
    "AddressOfEntryPoint",
    "BaseOfCode",
    "BaseOfData",
    "ImageBase",
    "SectionAlignment",
    "FileAlignment",
    "MajorOperatingSystemVersion",
    "MinorOperatingSystemVersion",
    "MajorImageVersion",
    "MinorImageVersion",
    "MajorSubsystemVersion",
    "MinorSubsystemVersion",
    "SizeOfImage",
    "SizeOfHeaders",
    "CheckSum",
    "Subsystem",
    "DllCharacteristics",
    "SizeOfStackReserve",
    "SizeOfStackCommit",
    "SizeOfHeapReserve",
    "SizeOfHeapCommit",
    "LoaderFlags",
    "NumberOfRvaAndSizes",
    "SectionsNb",
    "SectionsMeanEntropy",
    "SectionsMinEntropy",
    "SectionsMaxEntropy",
    "SectionsMeanRawsize",
    "SectionsMinRawsize",
    "SectionMaxRawsize",
    "SectionsMeanVirtualsize",
    "SectionsMinVirtualsize",
    "SectionMaxVirtualsize",
    "ImportsNbDLL",
    "ImportsNb",
    "ImportsNbOrdinal",
    "ExportNb",
    "ResourcesNb",
    "ResourcesMeanEntropy",
    "ResourcesMinEntropy",
    "ResourcesMaxEntropy",
    "ResourcesMeanSize",
    "ResourcesMinSize",
    "ResourcesMaxSize",
    "LoadConfigurationSize",
    "VersionInformationSize",
    "legitimate"
  ]
  # List of feature columns excluding 'Name', 'md5', and 'legitimate'
  feature_column = [x for x in columns if x not in ['Name', 'md5', 'legitimate']]

  # Create an argument parser for command-line arguments
  parser = argparse.ArgumentParser(description='Test if a file is malicious or legitimate.')
  parser.add_argument('file_path', help='Path to the file to be tested')
  args = parser.parse_args()

  # Get the file path from command-line arguments
  file_path = args.file_path
  if not os.path.isfile(file_path):
    print("Error: File not found.")
    sys.exit(1)

  try:
    # Load the best model from the classifiers directory
    clf = joblib.load('classifiers/best_model.pkl')

    # Load the feature names from the classifiers directory
    features = pickle.loads(open(os.path.join('classifiers/features.pkl'), 'rb').read())

    # Extract information from the given file path
    data = extract_infos(file_path)
    if data:
      # Get PE features for the given file
      pe_features = [data.get(feature, 0) for feature in feature_column]
      if hasattr(clf, 'predict'):
        # Predict whether the file is malicious or legitimate
        res = clf.predict([pe_features])[0]
        print("\n\nThe file '%s' is \033[1m%s\033[0m..." % (os.path.basename(file_path), ['malicious', 'legitimate'][res]))
      else:
        print("Error: Model object doesn't have 'predict' attribute.")
    else:
      print("Error: Failed to extract data from file.")
  except Exception as e:
    print("Error:", e)